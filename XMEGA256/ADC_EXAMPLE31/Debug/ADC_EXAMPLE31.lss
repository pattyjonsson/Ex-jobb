
ADC_EXAMPLE31.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000ab8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00802000  00000ab8  00000b4c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001d  00802006  00802006  00000b52  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000b52  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00000b84  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001e8  00000000  00000000  00000bc8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007897  00000000  00000000  00000db0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003fae  00000000  00000000  00008647  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003b93  00000000  00000000  0000c5f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000610  00000000  00000000  00010188  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000300c0  00000000  00000000  00010798  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000185c  00000000  00000000  00040858  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000188  00000000  00000000  000420b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000aa36  00000000  00000000  00042240  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	fd c0       	rjmp	.+506    	; 0x1fc <__ctors_end>
   2:	00 00       	nop
   4:	1a c1       	rjmp	.+564    	; 0x23a <__bad_interrupt>
   6:	00 00       	nop
   8:	18 c1       	rjmp	.+560    	; 0x23a <__bad_interrupt>
   a:	00 00       	nop
   c:	16 c1       	rjmp	.+556    	; 0x23a <__bad_interrupt>
   e:	00 00       	nop
  10:	14 c1       	rjmp	.+552    	; 0x23a <__bad_interrupt>
  12:	00 00       	nop
  14:	12 c1       	rjmp	.+548    	; 0x23a <__bad_interrupt>
  16:	00 00       	nop
  18:	10 c1       	rjmp	.+544    	; 0x23a <__bad_interrupt>
  1a:	00 00       	nop
  1c:	0e c1       	rjmp	.+540    	; 0x23a <__bad_interrupt>
  1e:	00 00       	nop
  20:	0c c1       	rjmp	.+536    	; 0x23a <__bad_interrupt>
  22:	00 00       	nop
  24:	0a c1       	rjmp	.+532    	; 0x23a <__bad_interrupt>
  26:	00 00       	nop
  28:	08 c1       	rjmp	.+528    	; 0x23a <__bad_interrupt>
  2a:	00 00       	nop
  2c:	06 c1       	rjmp	.+524    	; 0x23a <__bad_interrupt>
  2e:	00 00       	nop
  30:	04 c1       	rjmp	.+520    	; 0x23a <__bad_interrupt>
  32:	00 00       	nop
  34:	02 c1       	rjmp	.+516    	; 0x23a <__bad_interrupt>
  36:	00 00       	nop
  38:	00 c1       	rjmp	.+512    	; 0x23a <__bad_interrupt>
  3a:	00 00       	nop
  3c:	fe c0       	rjmp	.+508    	; 0x23a <__bad_interrupt>
  3e:	00 00       	nop
  40:	fc c0       	rjmp	.+504    	; 0x23a <__bad_interrupt>
  42:	00 00       	nop
  44:	fa c0       	rjmp	.+500    	; 0x23a <__bad_interrupt>
  46:	00 00       	nop
  48:	f8 c0       	rjmp	.+496    	; 0x23a <__bad_interrupt>
  4a:	00 00       	nop
  4c:	f6 c0       	rjmp	.+492    	; 0x23a <__bad_interrupt>
  4e:	00 00       	nop
  50:	f4 c0       	rjmp	.+488    	; 0x23a <__bad_interrupt>
  52:	00 00       	nop
  54:	f2 c0       	rjmp	.+484    	; 0x23a <__bad_interrupt>
  56:	00 00       	nop
  58:	f0 c0       	rjmp	.+480    	; 0x23a <__bad_interrupt>
  5a:	00 00       	nop
  5c:	ee c0       	rjmp	.+476    	; 0x23a <__bad_interrupt>
  5e:	00 00       	nop
  60:	ec c0       	rjmp	.+472    	; 0x23a <__bad_interrupt>
  62:	00 00       	nop
  64:	ea c0       	rjmp	.+468    	; 0x23a <__bad_interrupt>
  66:	00 00       	nop
  68:	e8 c0       	rjmp	.+464    	; 0x23a <__bad_interrupt>
  6a:	00 00       	nop
  6c:	e6 c0       	rjmp	.+460    	; 0x23a <__bad_interrupt>
  6e:	00 00       	nop
  70:	e4 c0       	rjmp	.+456    	; 0x23a <__bad_interrupt>
  72:	00 00       	nop
  74:	e2 c0       	rjmp	.+452    	; 0x23a <__bad_interrupt>
  76:	00 00       	nop
  78:	e0 c0       	rjmp	.+448    	; 0x23a <__bad_interrupt>
  7a:	00 00       	nop
  7c:	de c0       	rjmp	.+444    	; 0x23a <__bad_interrupt>
  7e:	00 00       	nop
  80:	dc c0       	rjmp	.+440    	; 0x23a <__bad_interrupt>
  82:	00 00       	nop
  84:	da c0       	rjmp	.+436    	; 0x23a <__bad_interrupt>
  86:	00 00       	nop
  88:	d8 c0       	rjmp	.+432    	; 0x23a <__bad_interrupt>
  8a:	00 00       	nop
  8c:	d6 c0       	rjmp	.+428    	; 0x23a <__bad_interrupt>
  8e:	00 00       	nop
  90:	d4 c0       	rjmp	.+424    	; 0x23a <__bad_interrupt>
  92:	00 00       	nop
  94:	d2 c0       	rjmp	.+420    	; 0x23a <__bad_interrupt>
  96:	00 00       	nop
  98:	d0 c0       	rjmp	.+416    	; 0x23a <__bad_interrupt>
  9a:	00 00       	nop
  9c:	82 c3       	rjmp	.+1796   	; 0x7a2 <__vector_39>
  9e:	00 00       	nop
  a0:	b2 c3       	rjmp	.+1892   	; 0x806 <__vector_40>
  a2:	00 00       	nop
  a4:	e2 c3       	rjmp	.+1988   	; 0x86a <__vector_41>
  a6:	00 00       	nop
  a8:	12 c4       	rjmp	.+2084   	; 0x8ce <__vector_42>
  aa:	00 00       	nop
  ac:	c6 c0       	rjmp	.+396    	; 0x23a <__bad_interrupt>
  ae:	00 00       	nop
  b0:	c4 c0       	rjmp	.+392    	; 0x23a <__bad_interrupt>
  b2:	00 00       	nop
  b4:	c2 c0       	rjmp	.+388    	; 0x23a <__bad_interrupt>
  b6:	00 00       	nop
  b8:	c0 c0       	rjmp	.+384    	; 0x23a <__bad_interrupt>
  ba:	00 00       	nop
  bc:	be c0       	rjmp	.+380    	; 0x23a <__bad_interrupt>
  be:	00 00       	nop
  c0:	bc c0       	rjmp	.+376    	; 0x23a <__bad_interrupt>
  c2:	00 00       	nop
  c4:	ba c0       	rjmp	.+372    	; 0x23a <__bad_interrupt>
  c6:	00 00       	nop
  c8:	b8 c0       	rjmp	.+368    	; 0x23a <__bad_interrupt>
  ca:	00 00       	nop
  cc:	b6 c0       	rjmp	.+364    	; 0x23a <__bad_interrupt>
  ce:	00 00       	nop
  d0:	b4 c0       	rjmp	.+360    	; 0x23a <__bad_interrupt>
  d2:	00 00       	nop
  d4:	b2 c0       	rjmp	.+356    	; 0x23a <__bad_interrupt>
  d6:	00 00       	nop
  d8:	b0 c0       	rjmp	.+352    	; 0x23a <__bad_interrupt>
  da:	00 00       	nop
  dc:	ae c0       	rjmp	.+348    	; 0x23a <__bad_interrupt>
  de:	00 00       	nop
  e0:	ac c0       	rjmp	.+344    	; 0x23a <__bad_interrupt>
  e2:	00 00       	nop
  e4:	aa c0       	rjmp	.+340    	; 0x23a <__bad_interrupt>
  e6:	00 00       	nop
  e8:	a8 c0       	rjmp	.+336    	; 0x23a <__bad_interrupt>
  ea:	00 00       	nop
  ec:	a6 c0       	rjmp	.+332    	; 0x23a <__bad_interrupt>
  ee:	00 00       	nop
  f0:	a4 c0       	rjmp	.+328    	; 0x23a <__bad_interrupt>
  f2:	00 00       	nop
  f4:	a2 c0       	rjmp	.+324    	; 0x23a <__bad_interrupt>
  f6:	00 00       	nop
  f8:	a0 c0       	rjmp	.+320    	; 0x23a <__bad_interrupt>
  fa:	00 00       	nop
  fc:	9e c0       	rjmp	.+316    	; 0x23a <__bad_interrupt>
  fe:	00 00       	nop
 100:	9c c0       	rjmp	.+312    	; 0x23a <__bad_interrupt>
 102:	00 00       	nop
 104:	9a c0       	rjmp	.+308    	; 0x23a <__bad_interrupt>
 106:	00 00       	nop
 108:	98 c0       	rjmp	.+304    	; 0x23a <__bad_interrupt>
 10a:	00 00       	nop
 10c:	96 c0       	rjmp	.+300    	; 0x23a <__bad_interrupt>
 10e:	00 00       	nop
 110:	94 c0       	rjmp	.+296    	; 0x23a <__bad_interrupt>
 112:	00 00       	nop
 114:	92 c0       	rjmp	.+292    	; 0x23a <__bad_interrupt>
 116:	00 00       	nop
 118:	90 c0       	rjmp	.+288    	; 0x23a <__bad_interrupt>
 11a:	00 00       	nop
 11c:	7a c2       	rjmp	.+1268   	; 0x612 <__vector_71>
 11e:	00 00       	nop
 120:	aa c2       	rjmp	.+1364   	; 0x676 <__vector_72>
 122:	00 00       	nop
 124:	da c2       	rjmp	.+1460   	; 0x6da <__vector_73>
 126:	00 00       	nop
 128:	0a c3       	rjmp	.+1556   	; 0x73e <__vector_74>
 12a:	00 00       	nop
 12c:	86 c0       	rjmp	.+268    	; 0x23a <__bad_interrupt>
 12e:	00 00       	nop
 130:	84 c0       	rjmp	.+264    	; 0x23a <__bad_interrupt>
 132:	00 00       	nop
 134:	82 c0       	rjmp	.+260    	; 0x23a <__bad_interrupt>
 136:	00 00       	nop
 138:	80 c0       	rjmp	.+256    	; 0x23a <__bad_interrupt>
 13a:	00 00       	nop
 13c:	7e c0       	rjmp	.+252    	; 0x23a <__bad_interrupt>
 13e:	00 00       	nop
 140:	7c c0       	rjmp	.+248    	; 0x23a <__bad_interrupt>
 142:	00 00       	nop
 144:	7a c0       	rjmp	.+244    	; 0x23a <__bad_interrupt>
 146:	00 00       	nop
 148:	78 c0       	rjmp	.+240    	; 0x23a <__bad_interrupt>
 14a:	00 00       	nop
 14c:	76 c0       	rjmp	.+236    	; 0x23a <__bad_interrupt>
 14e:	00 00       	nop
 150:	74 c0       	rjmp	.+232    	; 0x23a <__bad_interrupt>
 152:	00 00       	nop
 154:	72 c0       	rjmp	.+228    	; 0x23a <__bad_interrupt>
 156:	00 00       	nop
 158:	70 c0       	rjmp	.+224    	; 0x23a <__bad_interrupt>
 15a:	00 00       	nop
 15c:	6e c0       	rjmp	.+220    	; 0x23a <__bad_interrupt>
 15e:	00 00       	nop
 160:	6c c0       	rjmp	.+216    	; 0x23a <__bad_interrupt>
 162:	00 00       	nop
 164:	6a c0       	rjmp	.+212    	; 0x23a <__bad_interrupt>
 166:	00 00       	nop
 168:	68 c0       	rjmp	.+208    	; 0x23a <__bad_interrupt>
 16a:	00 00       	nop
 16c:	66 c0       	rjmp	.+204    	; 0x23a <__bad_interrupt>
 16e:	00 00       	nop
 170:	64 c0       	rjmp	.+200    	; 0x23a <__bad_interrupt>
 172:	00 00       	nop
 174:	62 c0       	rjmp	.+196    	; 0x23a <__bad_interrupt>
 176:	00 00       	nop
 178:	60 c0       	rjmp	.+192    	; 0x23a <__bad_interrupt>
 17a:	00 00       	nop
 17c:	5e c0       	rjmp	.+188    	; 0x23a <__bad_interrupt>
 17e:	00 00       	nop
 180:	5c c0       	rjmp	.+184    	; 0x23a <__bad_interrupt>
 182:	00 00       	nop
 184:	5a c0       	rjmp	.+180    	; 0x23a <__bad_interrupt>
 186:	00 00       	nop
 188:	58 c0       	rjmp	.+176    	; 0x23a <__bad_interrupt>
 18a:	00 00       	nop
 18c:	56 c0       	rjmp	.+172    	; 0x23a <__bad_interrupt>
 18e:	00 00       	nop
 190:	54 c0       	rjmp	.+168    	; 0x23a <__bad_interrupt>
 192:	00 00       	nop
 194:	52 c0       	rjmp	.+164    	; 0x23a <__bad_interrupt>
 196:	00 00       	nop
 198:	50 c0       	rjmp	.+160    	; 0x23a <__bad_interrupt>
 19a:	00 00       	nop
 19c:	4e c0       	rjmp	.+156    	; 0x23a <__bad_interrupt>
 19e:	00 00       	nop
 1a0:	4c c0       	rjmp	.+152    	; 0x23a <__bad_interrupt>
 1a2:	00 00       	nop
 1a4:	4a c0       	rjmp	.+148    	; 0x23a <__bad_interrupt>
 1a6:	00 00       	nop
 1a8:	48 c0       	rjmp	.+144    	; 0x23a <__bad_interrupt>
 1aa:	00 00       	nop
 1ac:	46 c0       	rjmp	.+140    	; 0x23a <__bad_interrupt>
 1ae:	00 00       	nop
 1b0:	44 c0       	rjmp	.+136    	; 0x23a <__bad_interrupt>
 1b2:	00 00       	nop
 1b4:	42 c0       	rjmp	.+132    	; 0x23a <__bad_interrupt>
 1b6:	00 00       	nop
 1b8:	40 c0       	rjmp	.+128    	; 0x23a <__bad_interrupt>
 1ba:	00 00       	nop
 1bc:	3e c0       	rjmp	.+124    	; 0x23a <__bad_interrupt>
 1be:	00 00       	nop
 1c0:	3c c0       	rjmp	.+120    	; 0x23a <__bad_interrupt>
 1c2:	00 00       	nop
 1c4:	3a c0       	rjmp	.+116    	; 0x23a <__bad_interrupt>
 1c6:	00 00       	nop
 1c8:	38 c0       	rjmp	.+112    	; 0x23a <__bad_interrupt>
 1ca:	00 00       	nop
 1cc:	36 c0       	rjmp	.+108    	; 0x23a <__bad_interrupt>
 1ce:	00 00       	nop
 1d0:	34 c0       	rjmp	.+104    	; 0x23a <__bad_interrupt>
 1d2:	00 00       	nop
 1d4:	32 c0       	rjmp	.+100    	; 0x23a <__bad_interrupt>
 1d6:	00 00       	nop
 1d8:	30 c0       	rjmp	.+96     	; 0x23a <__bad_interrupt>
 1da:	00 00       	nop
 1dc:	2e c0       	rjmp	.+92     	; 0x23a <__bad_interrupt>
 1de:	00 00       	nop
 1e0:	2c c0       	rjmp	.+88     	; 0x23a <__bad_interrupt>
 1e2:	00 00       	nop
 1e4:	2a c0       	rjmp	.+84     	; 0x23a <__bad_interrupt>
 1e6:	00 00       	nop
 1e8:	28 c0       	rjmp	.+80     	; 0x23a <__bad_interrupt>
 1ea:	00 00       	nop
 1ec:	26 c0       	rjmp	.+76     	; 0x23a <__bad_interrupt>
 1ee:	00 00       	nop
 1f0:	24 c0       	rjmp	.+72     	; 0x23a <__bad_interrupt>
 1f2:	00 00       	nop
 1f4:	22 c0       	rjmp	.+68     	; 0x23a <__bad_interrupt>
 1f6:	00 00       	nop
 1f8:	20 c0       	rjmp	.+64     	; 0x23a <__bad_interrupt>
	...

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e5       	ldi	r29, 0x5F	; 95
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_copy_data>:
 20c:	10 e2       	ldi	r17, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	e8 eb       	ldi	r30, 0xB8	; 184
 214:	fa e0       	ldi	r31, 0x0A	; 10
 216:	00 e0       	ldi	r16, 0x00	; 0
 218:	0b bf       	out	0x3b, r16	; 59
 21a:	02 c0       	rjmp	.+4      	; 0x220 <__do_copy_data+0x14>
 21c:	07 90       	elpm	r0, Z+
 21e:	0d 92       	st	X+, r0
 220:	a6 30       	cpi	r26, 0x06	; 6
 222:	b1 07       	cpc	r27, r17
 224:	d9 f7       	brne	.-10     	; 0x21c <__do_copy_data+0x10>

00000226 <__do_clear_bss>:
 226:	20 e2       	ldi	r18, 0x20	; 32
 228:	a6 e0       	ldi	r26, 0x06	; 6
 22a:	b0 e2       	ldi	r27, 0x20	; 32
 22c:	01 c0       	rjmp	.+2      	; 0x230 <.do_clear_bss_start>

0000022e <.do_clear_bss_loop>:
 22e:	1d 92       	st	X+, r1

00000230 <.do_clear_bss_start>:
 230:	a3 32       	cpi	r26, 0x23	; 35
 232:	b2 07       	cpc	r27, r18
 234:	e1 f7       	brne	.-8      	; 0x22e <.do_clear_bss_loop>
 236:	25 d0       	rcall	.+74     	; 0x282 <main>
 238:	3d c4       	rjmp	.+2170   	; 0xab4 <_exit>

0000023a <__bad_interrupt>:
 23a:	e2 ce       	rjmp	.-572    	; 0x0 <__vectors>

0000023c <adc_handler>:
 * \param adc Pointer to ADC module.
 * \param channel ADC channel number.
 * \param result Conversion result from ADC channel.
 */
static void adc_handler(ADC_t *adc, uint8_t ch_mask, adc_result_t result)
{
 23c:	0f 93       	push	r16
 23e:	1f 93       	push	r17
 240:	cf 93       	push	r28
 242:	c6 2f       	mov	r28, r22
 244:	8a 01       	movw	r16, r20

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	base->OUTTGL = arch_ioport_pin_to_mask(pin);
 246:	82 e0       	ldi	r24, 0x02	; 2
 248:	80 93 e7 07 	sts	0x07E7, r24	; 0x8007e7 <__TEXT_REGION_LENGTH__+0x7007e7>
	static uint8_t current_scan_channel = 0;
	
	gpio_toggle_pin(LED1_GPIO);
	delay(5000);
 24c:	88 e8       	ldi	r24, 0x88	; 136
 24e:	93 e1       	ldi	r25, 0x13	; 19
 250:	95 d0       	rcall	.+298    	; 0x37c <delay>
	// Store the ADC results from the scan in the result array
	if (ch_mask & ADC_CH0) {
 252:	c0 ff       	sbrs	r28, 0
 254:	12 c0       	rjmp	.+36     	; 0x27a <adc_handler+0x3e>
		adc_scan_results[current_scan_channel] = result;
 256:	80 91 06 20 	lds	r24, 0x2006	; 0x802006 <__data_end>
 25a:	e8 2f       	mov	r30, r24
 25c:	f0 e0       	ldi	r31, 0x00	; 0
 25e:	ee 0f       	add	r30, r30
 260:	ff 1f       	adc	r31, r31
 262:	e9 5f       	subi	r30, 0xF9	; 249
 264:	ff 4d       	sbci	r31, 0xDF	; 223
 266:	00 83       	st	Z, r16
 268:	11 83       	std	Z+1, r17	; 0x01
		current_scan_channel++;
 26a:	8f 5f       	subi	r24, 0xFF	; 255
		
		// When 8 pins have been scanned the SCAN OFFSET wraps to zero
		if (current_scan_channel == 8) {
 26c:	88 30       	cpi	r24, 0x08	; 8
 26e:	19 f0       	breq	.+6      	; 0x276 <adc_handler+0x3a>
	gpio_toggle_pin(LED1_GPIO);
	delay(5000);
	// Store the ADC results from the scan in the result array
	if (ch_mask & ADC_CH0) {
		adc_scan_results[current_scan_channel] = result;
		current_scan_channel++;
 270:	80 93 06 20 	sts	0x2006, r24	; 0x802006 <__data_end>
 274:	02 c0       	rjmp	.+4      	; 0x27a <adc_handler+0x3e>
		
		// When 8 pins have been scanned the SCAN OFFSET wraps to zero
		if (current_scan_channel == 8) {
			current_scan_channel = 0;
 276:	10 92 06 20 	sts	0x2006, r1	; 0x802006 <__data_end>
			
		}
	}
}
 27a:	cf 91       	pop	r28
 27c:	1f 91       	pop	r17
 27e:	0f 91       	pop	r16
 280:	08 95       	ret

00000282 <main>:

/**
 * \brief ADC Example 3 main application function
 */
int main(void)
{
 282:	cf 93       	push	r28
 284:	df 93       	push	r29
 286:	cd b7       	in	r28, 0x3d	; 61
 288:	de b7       	in	r29, 0x3e	; 62
 28a:	2b 97       	sbiw	r28, 0x0b	; 11
 28c:	cd bf       	out	0x3d, r28	; 61
	// ADC configuration structs
	struct adc_config         adc_conf;
	struct adc_channel_config adcch_conf;

	board_init();
	sysclk_init();
 28e:	de bf       	out	0x3e, r29	; 62
 290:	0d d1       	rcall	.+538    	; 0x4ac <board_init>
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t i;

	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
		sleepmgr_locks[i] = 0;
 292:	85 d0       	rcall	.+266    	; 0x39e <sysclk_init>
 294:	e9 e1       	ldi	r30, 0x19	; 25
 296:	f0 e2       	ldi	r31, 0x20	; 32
 298:	10 82       	st	Z, r1
 29a:	11 82       	std	Z+1, r1	; 0x01
 29c:	12 82       	std	Z+2, r1	; 0x02
 29e:	13 82       	std	Z+3, r1	; 0x03
	}
	sleepmgr_locks[SLEEPMGR_NR_OF_MODES - 1] = 1;
 2a0:	14 82       	std	Z+4, r1	; 0x04
 2a2:	81 e0       	ldi	r24, 0x01	; 1
	sleepmgr_init();
	irq_initialize_vectors();
 2a4:	85 83       	std	Z+5, r24	; 0x05
 2a6:	17 e0       	ldi	r17, 0x07	; 7
 2a8:	10 93 a2 00 	sts	0x00A2, r17	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	cpu_irq_enable();

	// Clear the configuration structures.
	memset(&adc_conf, 0, sizeof(struct adc_config));
 2ac:	78 94       	sei
 2ae:	be 01       	movw	r22, r28
 2b0:	6f 5f       	subi	r22, 0xFF	; 255
 2b2:	7f 4f       	sbci	r23, 0xFF	; 255
 2b4:	db 01       	movw	r26, r22
 2b6:	e1 2f       	mov	r30, r17
 2b8:	1d 92       	st	X+, r1
 2ba:	ea 95       	dec	r30
	memset(&adcch_conf, 0, sizeof(struct adc_channel_config));
 2bc:	e9 f7       	brne	.-6      	; 0x2b8 <main+0x36>
 2be:	7e 01       	movw	r14, r28
 2c0:	f8 e0       	ldi	r31, 0x08	; 8
 2c2:	ef 0e       	add	r14, r31
 2c4:	f1 1c       	adc	r15, r1
 2c6:	84 e0       	ldi	r24, 0x04	; 4
 2c8:	d7 01       	movw	r26, r14
 2ca:	1d 92       	st	X+, r1
 2cc:	8a 95       	dec	r24
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
 2ce:	e9 f7       	brne	.-6      	; 0x2ca <main+0x48>
 2d0:	86 e0       	ldi	r24, 0x06	; 6
		conf->evctrl = (nr_of_ch - 1) << ADC_SWEEP_gp;
		break;

	case ADC_TRIG_EVENT_SWEEP:
		conf->ctrlb &= ~ADC_FREERUN_bm;
		conf->evctrl = (nr_of_ch - 1) << ADC_SWEEP_gp |
 2d2:	8d 83       	std	Y+5, r24	; 0x05
 2d4:	85 e0       	ldi	r24, 0x05	; 5
	case ADC_CURRENT_LIMIT_MED:
		conf->ctrlb |= ADC_CURRLIMIT_MED_gc;
		break;

	case ADC_CURRENT_LIMIT_HIGH:
		conf->ctrlb |= ADC_CURRLIMIT_HIGH_gc;
 2d6:	8c 83       	std	Y+4, r24	; 0x04
 2d8:	80 e7       	ldi	r24, 0x70	; 112
 * \arg \c ADC_INT_BANDGAP for bandgap reference.
 */
static inline void adc_enable_internal_input(struct adc_config *conf,
		uint8_t int_inp)
{
	conf->refctrl |= int_inp;
 2da:	8a 83       	std	Y+2, r24	; 0x02
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_EVENT_SWEEP, 1, 0);
	adc_set_current_limit(&adc_conf, ADC_CURRENT_LIMIT_HIGH);
	adc_set_gain_impedance_mode(&adc_conf, ADC_GAIN_HIGHIMPEDANCE);
	adc_enable_internal_input(&adc_conf, ADC_INT_BANDGAP);

	adc_write_configuration(&ADCA, &adc_conf);
 2dc:	02 e0       	ldi	r16, 0x02	; 2
 2de:	0b 83       	std	Y+3, r16	; 0x03
 2e0:	80 e0       	ldi	r24, 0x00	; 0
	adc_set_callback(&ADCA, &adc_handler);
 2e2:	92 e0       	ldi	r25, 0x02	; 2
 2e4:	26 d3       	rcall	.+1612   	; 0x932 <adc_write_configuration>
 2e6:	6e e1       	ldi	r22, 0x1E	; 30
 2e8:	71 e0       	ldi	r23, 0x01	; 1
 2ea:	80 e0       	ldi	r24, 0x00	; 0
		 * gain is enabled. To avoid unnecessary current consumption,
		 * do not enable gainstage for unity gain unless user explicitly
		 * specifies it with the ADCCH_FORCE_1X_GAINSTAGE macro.
		 */
		if (gain == 1) {
			ch_conf->ctrl = ADC_CH_INPUTMODE_DIFF_gc;
 2ec:	92 e0       	ldi	r25, 0x02	; 2
			ch_conf->muxctrl = (pos << ADC_CH_MUXPOS_gp) |
 2ee:	09 d1       	rcall	.+530    	; 0x502 <adc_set_callback>
 * \param ch_conf Pointer to ADC channel configuration.
 */
static inline void adcch_enable_interrupt(struct adc_channel_config *ch_conf)
{
	ch_conf->intctrl &= ~ADC_CH_INTLVL_gm;
	ch_conf->intctrl |= CONFIG_ADC_INTLVL;
 2f0:	08 87       	std	Y+8, r16	; 0x08
 2f2:	19 87       	std	Y+9, r17	; 0x09
 2f4:	8a 85       	ldd	r24, Y+10	; 0x0a
 2f6:	80 7f       	andi	r24, 0xF0	; 240
	adcch_set_input(&adcch_conf, ADCCH_POS_PIN0, ADCCH_NEG_INTERNAL_GND, 1);
	adcch_set_interrupt_mode(&adcch_conf, ADCCH_MODE_COMPLETE);
	adcch_enable_interrupt(&adcch_conf);
	adcch_set_pin_scan(&adcch_conf, 0, 7);

	adcch_write_configuration(&ADCA, ADC_CH0, &adcch_conf);
 2f8:	81 60       	ori	r24, 0x01	; 1
 2fa:	8a 87       	std	Y+10, r24	; 0x0a
 2fc:	1b 87       	std	Y+11, r17	; 0x0b
 2fe:	a7 01       	movw	r20, r14

	// Enable the Event System to use as trigger source
	sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
 300:	61 e0       	ldi	r22, 0x01	; 1
 302:	80 e0       	ldi	r24, 0x00	; 0
 304:	92 e0       	ldi	r25, 0x02	; 2
	// Conversion 62500 times a second
	EVSYS.CH0MUX = EVSYS_CHMUX_PRESCALER_512_gc;
 306:	7b d3       	rcall	.+1782   	; 0x9fe <adcch_write_configuration>
 308:	62 e0       	ldi	r22, 0x02	; 2
 30a:	80 e0       	ldi	r24, 0x00	; 0

	// Enable the ADC
	adc_enable(&ADCA);
 30c:	7d d0       	rcall	.+250    	; 0x408 <sysclk_enable_module>
 30e:	89 e8       	ldi	r24, 0x89	; 137
 310:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>
	set_sleep_mode(SLEEP_MODE_PWR_SAVE);
 314:	80 e0       	ldi	r24, 0x00	; 0
 316:	92 e0       	ldi	r25, 0x02	; 2
 318:	50 d1       	rcall	.+672    	; 0x5ba <adc_enable>
 31a:	e8 e4       	ldi	r30, 0x48	; 72
 31c:	f0 e0       	ldi	r31, 0x00	; 0
 31e:	80 81       	ld	r24, Z
	sleep_enable();
 320:	81 7f       	andi	r24, 0xF1	; 241
 322:	86 60       	ori	r24, 0x06	; 6
 324:	80 83       	st	Z, r24

#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t *lock_ptr = sleepmgr_locks;

	// Find first non-zero lock count, starting with the shallowest modes.
	while (!(*lock_ptr)) {
 326:	80 81       	ld	r24, Z
 328:	81 60       	ori	r24, 0x01	; 1
 *
 * \param mode Sleep mode, from the device IO header file.
 */
static inline void sleep_set_mode(enum SLEEP_SMODE_enum mode)
{
	SLEEP.CTRL = mode | (SLEEP.CTRL & ~SLEEP_SMODE_gm);
 32a:	80 83       	st	Z, r24
 32c:	49 e1       	ldi	r20, 0x19	; 25
static inline void sleepmgr_enter_sleep(void)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	enum sleepmgr_mode sleep_mode;

	cpu_irq_disable();
 32e:	50 e2       	ldi	r21, 0x20	; 32

#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t *lock_ptr = sleepmgr_locks;

	// Find first non-zero lock count, starting with the shallowest modes.
	while (!(*lock_ptr)) {
 330:	28 e4       	ldi	r18, 0x48	; 72
 332:	30 e0       	ldi	r19, 0x00	; 0
 334:	f8 94       	cli
 336:	fa 01       	movw	r30, r20
 338:	80 81       	ld	r24, Z
 33a:	81 11       	cpse	r24, r1
 33c:	09 c0       	rjmp	.+18     	; 0x350 <main+0xce>
		lock_ptr++;
		sleep_mode = (enum sleepmgr_mode)(sleep_mode + 1);
 33e:	aa e1       	ldi	r26, 0x1A	; 26

#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t *lock_ptr = sleepmgr_locks;

	// Find first non-zero lock count, starting with the shallowest modes.
	while (!(*lock_ptr)) {
 340:	b0 e2       	ldi	r27, 0x20	; 32
 342:	e0 e0       	ldi	r30, 0x00	; 0
 344:	ef 5f       	subi	r30, 0xFF	; 255
	cpu_irq_disable();

	// Find the deepest allowable sleep mode
	sleep_mode = sleepmgr_get_sleep_mode();
	// Return right away if first mode (ACTIVE) is locked.
	if (sleep_mode==SLEEPMGR_ACTIVE) {
 346:	8d 91       	ld	r24, X+
 348:	88 23       	and	r24, r24
		cpu_irq_enable();
 34a:	e1 f3       	breq	.-8      	; 0x344 <main+0xc2>
 34c:	e1 11       	cpse	r30, r1
 34e:	02 c0       	rjmp	.+4      	; 0x354 <main+0xd2>
 350:	78 94       	sei

static inline void sleepmgr_sleep(const enum sleepmgr_mode sleep_mode)
{
	Assert(sleep_mode != SLEEPMGR_ACTIVE);
#ifdef CONFIG_SLEEPMGR_ENABLE
	sleep_set_mode(sleepmgr_configs[sleep_mode-1]);
 352:	12 c0       	rjmp	.+36     	; 0x378 <main+0xf6>
 354:	d9 01       	movw	r26, r18
 356:	8c 91       	ld	r24, X
 358:	f0 e0       	ldi	r31, 0x00	; 0
 35a:	e1 50       	subi	r30, 0x01	; 1
 35c:	f0 4e       	sbci	r31, 0xE0	; 224
 35e:	81 7f       	andi	r24, 0xF1	; 241
	sleep_enable();
 360:	90 81       	ld	r25, Z
 362:	89 2b       	or	r24, r25
 364:	8c 93       	st	X, r24

	cpu_irq_enable();
 366:	8c 91       	ld	r24, X
	sleep_enter();
 368:	81 60       	ori	r24, 0x01	; 1

	sleep_disable();
 36a:	8c 93       	st	X, r24
 36c:	78 94       	sei
 36e:	88 95       	sleep
 370:	f9 01       	movw	r30, r18
	do {
		// Sleep until ADC interrupt triggers.
		sleepmgr_enter_sleep();
		sleep_cpu();
 372:	80 81       	ld	r24, Z
	} while (1);
 374:	8e 7f       	andi	r24, 0xFE	; 254
 376:	80 83       	st	Z, r24
 378:	88 95       	sleep
 37a:	dc cf       	rjmp	.-72     	; 0x334 <main+0xb2>

0000037c <delay>:
 #include "asf.h"



 void delay (uint16_t length)
 {
 37c:	ac 01       	movw	r20, r24
	 // Simple delay loop
	 for (uint16_t i=0; i<length; i++) {
 37e:	89 2b       	or	r24, r25
 380:	51 f4       	brne	.+20     	; 0x396 <delay+0x1a>
 382:	08 95       	ret
		 for (uint8_t j=0; j<255; j++) {
			 asm volatile("nop");
 384:	00 00       	nop
 386:	91 50       	subi	r25, 0x01	; 1

 void delay (uint16_t length)
 {
	 // Simple delay loop
	 for (uint16_t i=0; i<length; i++) {
		 for (uint8_t j=0; j<255; j++) {
 388:	e9 f7       	brne	.-6      	; 0x384 <delay+0x8>


 void delay (uint16_t length)
 {
	 // Simple delay loop
	 for (uint16_t i=0; i<length; i++) {
 38a:	2f 5f       	subi	r18, 0xFF	; 255
 38c:	3f 4f       	sbci	r19, 0xFF	; 255
 38e:	42 17       	cp	r20, r18
 390:	53 07       	cpc	r21, r19
 392:	19 f4       	brne	.+6      	; 0x39a <delay+0x1e>
 394:	08 95       	ret
 396:	20 e0       	ldi	r18, 0x00	; 0
 398:	30 e0       	ldi	r19, 0x00	; 0
 #include "asf.h"



 void delay (uint16_t length)
 {
 39a:	9f ef       	ldi	r25, 0xFF	; 255
 39c:	f3 cf       	rjmp	.-26     	; 0x384 <delay+0x8>

0000039e <sysclk_init>:
#  include <nvm.h>
#endif


void sysclk_init(void)
{
 39e:	cf 93       	push	r28
 3a0:	df 93       	push	r29
 3a2:	1f 92       	push	r1
 3a4:	1f 92       	push	r1
 3a6:	cd b7       	in	r28, 0x3d	; 61
 3a8:	de b7       	in	r29, 0x3e	; 62
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
 3aa:	8f ef       	ldi	r24, 0xFF	; 255
 3ac:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
 3b0:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
 3b4:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
 3b8:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
 3bc:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x700074>
 3c0:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <__TEXT_REGION_LENGTH__+0x700075>
 3c4:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__TEXT_REGION_LENGTH__+0x700076>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
 3c8:	8f b7       	in	r24, 0x3f	; 63
 3ca:	8a 83       	std	Y+2, r24	; 0x02
	cpu_irq_disable();
 3cc:	f8 94       	cli
	return flags;
 3ce:	9a 81       	ldd	r25, Y+2	; 0x02
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL |= id;
 3d0:	e0 e5       	ldi	r30, 0x50	; 80
 3d2:	f0 e0       	ldi	r31, 0x00	; 0
 3d4:	80 81       	ld	r24, Z
 3d6:	82 60       	ori	r24, 0x02	; 2
 3d8:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 3da:	9f bf       	out	0x3f, r25	; 63

static inline bool osc_is_ready(uint8_t id)
{
	Assert(id != OSC_ID_USBSOF);

	return OSC.STATUS & id;
 3dc:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
 3de:	81 ff       	sbrs	r24, 1
 3e0:	fd cf       	rjmp	.-6      	; 0x3dc <sysclk_init+0x3e>
		default:
			//unhandled_case(CONFIG_SYSCLK_SOURCE);
			return;
		}

		ccp_write_io((uint8_t *)&CLK.CTRL, CONFIG_SYSCLK_SOURCE);
 3e2:	61 e0       	ldi	r22, 0x01	; 1
 3e4:	80 e4       	ldi	r24, 0x40	; 64
 3e6:	90 e0       	ldi	r25, 0x00	; 0
 3e8:	55 d3       	rcall	.+1706   	; 0xa94 <ccp_write_io>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
 3ea:	8f b7       	in	r24, 0x3f	; 63
 3ec:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
 3ee:	f8 94       	cli
	return flags;
 3f0:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL &= ~id;
 3f2:	e0 e5       	ldi	r30, 0x50	; 80
 3f4:	f0 e0       	ldi	r31, 0x00	; 0
 3f6:	80 81       	ld	r24, Z
 3f8:	8e 7f       	andi	r24, 0xFE	; 254
 3fa:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 3fc:	9f bf       	out	0x3f, r25	; 63
	}

#ifdef CONFIG_RTC_SOURCE
	sysclk_rtcsrc_enable(CONFIG_RTC_SOURCE);
#endif
}
 3fe:	0f 90       	pop	r0
 400:	0f 90       	pop	r0
 402:	df 91       	pop	r29
 404:	cf 91       	pop	r28
 406:	08 95       	ret

00000408 <sysclk_enable_module>:

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
 408:	cf 93       	push	r28
 40a:	df 93       	push	r29
 40c:	1f 92       	push	r1
 40e:	cd b7       	in	r28, 0x3d	; 61
 410:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
 412:	9f b7       	in	r25, 0x3f	; 63
 414:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
 416:	f8 94       	cli
	return flags;
 418:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
 41a:	e8 2f       	mov	r30, r24
 41c:	f0 e0       	ldi	r31, 0x00	; 0
 41e:	e0 59       	subi	r30, 0x90	; 144
 420:	ff 4f       	sbci	r31, 0xFF	; 255
 422:	60 95       	com	r22
 424:	80 81       	ld	r24, Z
 426:	68 23       	and	r22, r24
 428:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 42a:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
 42c:	0f 90       	pop	r0
 42e:	df 91       	pop	r29
 430:	cf 91       	pop	r28
 432:	08 95       	ret

00000434 <sysclk_disable_module>:

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
 434:	cf 93       	push	r28
 436:	df 93       	push	r29
 438:	1f 92       	push	r1
 43a:	cd b7       	in	r28, 0x3d	; 61
 43c:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
 43e:	9f b7       	in	r25, 0x3f	; 63
 440:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
 442:	f8 94       	cli
	return flags;
 444:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
 446:	e8 2f       	mov	r30, r24
 448:	f0 e0       	ldi	r31, 0x00	; 0
 44a:	e0 59       	subi	r30, 0x90	; 144
 44c:	ff 4f       	sbci	r31, 0xFF	; 255
 44e:	80 81       	ld	r24, Z
 450:	68 2b       	or	r22, r24
 452:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 454:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
 456:	0f 90       	pop	r0
 458:	df 91       	pop	r29
 45a:	cf 91       	pop	r28
 45c:	08 95       	ret

0000045e <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
 45e:	cf 93       	push	r28
 460:	df 93       	push	r29
 462:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
 464:	20 e0       	ldi	r18, 0x00	; 0
 466:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
 468:	c6 2f       	mov	r28, r22
 46a:	d0 e0       	ldi	r29, 0x00	; 0
 46c:	de 01       	movw	r26, r28
 46e:	02 2e       	mov	r0, r18
 470:	02 c0       	rjmp	.+4      	; 0x476 <ioport_configure_port_pin+0x18>
 472:	b5 95       	asr	r27
 474:	a7 95       	ror	r26
 476:	0a 94       	dec	r0
 478:	e2 f7       	brpl	.-8      	; 0x472 <ioport_configure_port_pin+0x14>
 47a:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
 47c:	50 8b       	std	Z+16, r21	; 0x10
 47e:	2f 5f       	subi	r18, 0xFF	; 255
 480:	3f 4f       	sbci	r19, 0xFF	; 255
 482:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
 484:	28 30       	cpi	r18, 0x08	; 8
 486:	31 05       	cpc	r19, r1
 488:	89 f7       	brne	.-30     	; 0x46c <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
 48a:	40 ff       	sbrs	r20, 0
 48c:	0a c0       	rjmp	.+20     	; 0x4a2 <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
 48e:	41 ff       	sbrs	r20, 1
 490:	03 c0       	rjmp	.+6      	; 0x498 <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
 492:	fc 01       	movw	r30, r24
 494:	65 83       	std	Z+5, r22	; 0x05
 496:	02 c0       	rjmp	.+4      	; 0x49c <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
 498:	fc 01       	movw	r30, r24
 49a:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
 49c:	fc 01       	movw	r30, r24
 49e:	61 83       	std	Z+1, r22	; 0x01
 4a0:	02 c0       	rjmp	.+4      	; 0x4a6 <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
 4a2:	fc 01       	movw	r30, r24
 4a4:	62 83       	std	Z+2, r22	; 0x02
	}
}
 4a6:	df 91       	pop	r29
 4a8:	cf 91       	pop	r28
 4aa:	08 95       	ret

000004ac <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
 4ac:	43 e0       	ldi	r20, 0x03	; 3
 4ae:	50 e0       	ldi	r21, 0x00	; 0
 4b0:	61 e0       	ldi	r22, 0x01	; 1
 4b2:	80 ee       	ldi	r24, 0xE0	; 224
 4b4:	97 e0       	ldi	r25, 0x07	; 7
 4b6:	d3 df       	rcall	.-90     	; 0x45e <ioport_configure_port_pin>
 4b8:	43 e0       	ldi	r20, 0x03	; 3
 4ba:	50 e0       	ldi	r21, 0x00	; 0
 4bc:	62 e0       	ldi	r22, 0x02	; 2
 4be:	80 ee       	ldi	r24, 0xE0	; 224
 4c0:	97 e0       	ldi	r25, 0x07	; 7
 4c2:	cd df       	rcall	.-102    	; 0x45e <ioport_configure_port_pin>
 4c4:	43 e0       	ldi	r20, 0x03	; 3
 4c6:	50 e0       	ldi	r21, 0x00	; 0
 4c8:	60 e1       	ldi	r22, 0x10	; 16
 4ca:	80 e6       	ldi	r24, 0x60	; 96
 4cc:	96 e0       	ldi	r25, 0x06	; 6
 4ce:	c7 df       	rcall	.-114    	; 0x45e <ioport_configure_port_pin>
 4d0:	41 e0       	ldi	r20, 0x01	; 1
 4d2:	50 e4       	ldi	r21, 0x40	; 64
 4d4:	60 e2       	ldi	r22, 0x20	; 32
 4d6:	80 e6       	ldi	r24, 0x60	; 96
 4d8:	96 e0       	ldi	r25, 0x06	; 6
 4da:	c1 df       	rcall	.-126    	; 0x45e <ioport_configure_port_pin>
 4dc:	40 e0       	ldi	r20, 0x00	; 0
 4de:	5b e1       	ldi	r21, 0x1B	; 27
 4e0:	60 e2       	ldi	r22, 0x20	; 32
 4e2:	80 e8       	ldi	r24, 0x80	; 128
 4e4:	96 e0       	ldi	r25, 0x06	; 6
 4e6:	bb df       	rcall	.-138    	; 0x45e <ioport_configure_port_pin>
 4e8:	40 e0       	ldi	r20, 0x00	; 0
 4ea:	5b e1       	ldi	r21, 0x1B	; 27
 4ec:	62 e0       	ldi	r22, 0x02	; 2
 4ee:	80 ea       	ldi	r24, 0xA0	; 160
 4f0:	96 e0       	ldi	r25, 0x06	; 6
 4f2:	b5 df       	rcall	.-150    	; 0x45e <ioport_configure_port_pin>
 4f4:	40 e0       	ldi	r20, 0x00	; 0
 4f6:	5b e1       	ldi	r21, 0x1B	; 27
 4f8:	64 e0       	ldi	r22, 0x04	; 4
 4fa:	80 ea       	ldi	r24, 0xA0	; 160
 4fc:	96 e0       	ldi	r25, 0x06	; 6
 4fe:	af cf       	rjmp	.-162    	; 0x45e <ioport_configure_port_pin>
 500:	08 95       	ret

00000502 <adc_set_callback>:
 *
 * \param adc Pointer to ADC module.
 * \param callback Pointer to the callback function to set.
 */
void adc_set_callback(ADC_t *adc, adc_callback_t callback)
{
 502:	cf 93       	push	r28
 504:	df 93       	push	r29
 506:	1f 92       	push	r1
 508:	cd b7       	in	r28, 0x3d	; 61
 50a:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
 50c:	2f b7       	in	r18, 0x3f	; 63
 50e:	29 83       	std	Y+1, r18	; 0x01
	cpu_irq_disable();
 510:	f8 94       	cli
	return flags;
 512:	49 81       	ldd	r20, Y+1	; 0x01
	Assert(callback);

	flags = cpu_irq_save();

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
 514:	28 2f       	mov	r18, r24
 516:	39 2f       	mov	r19, r25
 518:	21 15       	cp	r18, r1
 51a:	82 e0       	ldi	r24, 0x02	; 2
 51c:	38 07       	cpc	r19, r24
 51e:	29 f4       	brne	.+10     	; 0x52a <adc_set_callback+0x28>
		adca_callback = callback;
 520:	60 93 21 20 	sts	0x2021, r22	; 0x802021 <adca_callback>
 524:	70 93 22 20 	sts	0x2022, r23	; 0x802022 <adca_callback+0x1>
 528:	07 c0       	rjmp	.+14     	; 0x538 <adc_set_callback+0x36>
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
 52a:	20 34       	cpi	r18, 0x40	; 64
 52c:	32 40       	sbci	r19, 0x02	; 2
 52e:	21 f4       	brne	.+8      	; 0x538 <adc_set_callback+0x36>
		adcb_callback = callback;
 530:	60 93 1f 20 	sts	0x201F, r22	; 0x80201f <adcb_callback>
 534:	70 93 20 20 	sts	0x2020, r23	; 0x802020 <adcb_callback+0x1>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 538:	4f bf       	out	0x3f, r20	; 63
	{
		Assert(0);
	}

	cpu_irq_restore(flags);
}
 53a:	0f 90       	pop	r0
 53c:	df 91       	pop	r29
 53e:	cf 91       	pop	r28
 540:	08 95       	ret

00000542 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
 542:	81 15       	cp	r24, r1
 544:	22 e0       	ldi	r18, 0x02	; 2
 546:	92 07       	cpc	r25, r18
 548:	61 f4       	brne	.+24     	; 0x562 <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
 54a:	80 91 18 20 	lds	r24, 0x2018	; 0x802018 <adca_enable_count>
 54e:	91 e0       	ldi	r25, 0x01	; 1
 550:	98 0f       	add	r25, r24
 552:	90 93 18 20 	sts	0x2018, r25	; 0x802018 <adca_enable_count>
 556:	81 11       	cpse	r24, r1
 558:	12 c0       	rjmp	.+36     	; 0x57e <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
 55a:	62 e0       	ldi	r22, 0x02	; 2
 55c:	81 e0       	ldi	r24, 0x01	; 1
 55e:	54 cf       	rjmp	.-344    	; 0x408 <sysclk_enable_module>
 560:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
 562:	80 34       	cpi	r24, 0x40	; 64
 564:	92 40       	sbci	r25, 0x02	; 2
 566:	59 f4       	brne	.+22     	; 0x57e <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
 568:	80 91 17 20 	lds	r24, 0x2017	; 0x802017 <adcb_enable_count>
 56c:	91 e0       	ldi	r25, 0x01	; 1
 56e:	98 0f       	add	r25, r24
 570:	90 93 17 20 	sts	0x2017, r25	; 0x802017 <adcb_enable_count>
 574:	81 11       	cpse	r24, r1
 576:	03 c0       	rjmp	.+6      	; 0x57e <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
 578:	62 e0       	ldi	r22, 0x02	; 2
 57a:	82 e0       	ldi	r24, 0x02	; 2
 57c:	45 cf       	rjmp	.-374    	; 0x408 <sysclk_enable_module>
 57e:	08 95       	ret

00000580 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
 580:	81 15       	cp	r24, r1
 582:	22 e0       	ldi	r18, 0x02	; 2
 584:	92 07       	cpc	r25, r18
 586:	59 f4       	brne	.+22     	; 0x59e <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
 588:	80 91 18 20 	lds	r24, 0x2018	; 0x802018 <adca_enable_count>
 58c:	81 50       	subi	r24, 0x01	; 1
 58e:	80 93 18 20 	sts	0x2018, r24	; 0x802018 <adca_enable_count>
 592:	81 11       	cpse	r24, r1
 594:	11 c0       	rjmp	.+34     	; 0x5b8 <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
 596:	62 e0       	ldi	r22, 0x02	; 2
 598:	81 e0       	ldi	r24, 0x01	; 1
 59a:	4c cf       	rjmp	.-360    	; 0x434 <sysclk_disable_module>
 59c:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
 59e:	80 34       	cpi	r24, 0x40	; 64
 5a0:	92 40       	sbci	r25, 0x02	; 2
 5a2:	51 f4       	brne	.+20     	; 0x5b8 <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
 5a4:	80 91 17 20 	lds	r24, 0x2017	; 0x802017 <adcb_enable_count>
 5a8:	81 50       	subi	r24, 0x01	; 1
 5aa:	80 93 17 20 	sts	0x2017, r24	; 0x802017 <adcb_enable_count>
 5ae:	81 11       	cpse	r24, r1
 5b0:	03 c0       	rjmp	.+6      	; 0x5b8 <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
 5b2:	62 e0       	ldi	r22, 0x02	; 2
 5b4:	82 e0       	ldi	r24, 0x02	; 2
 5b6:	3e cf       	rjmp	.-388    	; 0x434 <sysclk_disable_module>
 5b8:	08 95       	ret

000005ba <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
 5ba:	ef 92       	push	r14
 5bc:	ff 92       	push	r15
 5be:	1f 93       	push	r17
 5c0:	cf 93       	push	r28
 5c2:	df 93       	push	r29
 5c4:	1f 92       	push	r1
 5c6:	1f 92       	push	r1
 5c8:	cd b7       	in	r28, 0x3d	; 61
 5ca:	de b7       	in	r29, 0x3e	; 62
 5cc:	7c 01       	movw	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
 5ce:	8f b7       	in	r24, 0x3f	; 63
 5d0:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
 5d2:	f8 94       	cli
	return flags;
 5d4:	19 81       	ldd	r17, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
 5d6:	c7 01       	movw	r24, r14
 5d8:	b4 df       	rcall	.-152    	; 0x542 <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
 5da:	f7 01       	movw	r30, r14
 5dc:	80 81       	ld	r24, Z
 5de:	81 60       	ori	r24, 0x01	; 1
 5e0:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 5e2:	1f bf       	out	0x3f, r17	; 63
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
 5e4:	80 91 1a 20 	lds	r24, 0x201A	; 0x80201a <sleepmgr_locks+0x1>
 5e8:	8f 3f       	cpi	r24, 0xFF	; 255
 5ea:	09 f4       	brne	.+2      	; 0x5ee <adc_enable+0x34>
 5ec:	ff cf       	rjmp	.-2      	; 0x5ec <adc_enable+0x32>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
 5ee:	8f b7       	in	r24, 0x3f	; 63
 5f0:	8a 83       	std	Y+2, r24	; 0x02
	cpu_irq_disable();
 5f2:	f8 94       	cli
	return flags;
 5f4:	9a 81       	ldd	r25, Y+2	; 0x02
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
 5f6:	e9 e1       	ldi	r30, 0x19	; 25
 5f8:	f0 e2       	ldi	r31, 0x20	; 32
 5fa:	81 81       	ldd	r24, Z+1	; 0x01
 5fc:	8f 5f       	subi	r24, 0xFF	; 255
 5fe:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 600:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
 602:	0f 90       	pop	r0
 604:	0f 90       	pop	r0
 606:	df 91       	pop	r29
 608:	cf 91       	pop	r28
 60a:	1f 91       	pop	r17
 60c:	ff 90       	pop	r15
 60e:	ef 90       	pop	r14
 610:	08 95       	ret

00000612 <__vector_71>:
	conf->ctrlb = adc->CTRLB;

	adc_disable_clock(adc);

	cpu_irq_restore(flags);
}
 612:	1f 92       	push	r1
 614:	0f 92       	push	r0
 616:	0f b6       	in	r0, 0x3f	; 63
 618:	0f 92       	push	r0
 61a:	11 24       	eor	r1, r1
 61c:	0b b6       	in	r0, 0x3b	; 59
 61e:	0f 92       	push	r0
 620:	2f 93       	push	r18
 622:	3f 93       	push	r19
 624:	4f 93       	push	r20
 626:	5f 93       	push	r21
 628:	6f 93       	push	r22
 62a:	7f 93       	push	r23
 62c:	8f 93       	push	r24
 62e:	9f 93       	push	r25
 630:	af 93       	push	r26
 632:	bf 93       	push	r27
 634:	ef 93       	push	r30
 636:	ff 93       	push	r31
 638:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
 63c:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
 640:	e0 91 21 20 	lds	r30, 0x2021	; 0x802021 <adca_callback>
 644:	f0 91 22 20 	lds	r31, 0x2022	; 0x802022 <adca_callback+0x1>
 648:	61 e0       	ldi	r22, 0x01	; 1
 64a:	80 e0       	ldi	r24, 0x00	; 0
 64c:	92 e0       	ldi	r25, 0x02	; 2
 64e:	19 95       	eicall
 650:	ff 91       	pop	r31
 652:	ef 91       	pop	r30
 654:	bf 91       	pop	r27
 656:	af 91       	pop	r26
 658:	9f 91       	pop	r25
 65a:	8f 91       	pop	r24
 65c:	7f 91       	pop	r23
 65e:	6f 91       	pop	r22
 660:	5f 91       	pop	r21
 662:	4f 91       	pop	r20
 664:	3f 91       	pop	r19
 666:	2f 91       	pop	r18
 668:	0f 90       	pop	r0
 66a:	0b be       	out	0x3b, r0	; 59
 66c:	0f 90       	pop	r0
 66e:	0f be       	out	0x3f, r0	; 63
 670:	0f 90       	pop	r0
 672:	1f 90       	pop	r1
 674:	18 95       	reti

00000676 <__vector_72>:
 676:	1f 92       	push	r1
 678:	0f 92       	push	r0
 67a:	0f b6       	in	r0, 0x3f	; 63
 67c:	0f 92       	push	r0
 67e:	11 24       	eor	r1, r1
 680:	0b b6       	in	r0, 0x3b	; 59
 682:	0f 92       	push	r0
 684:	2f 93       	push	r18
 686:	3f 93       	push	r19
 688:	4f 93       	push	r20
 68a:	5f 93       	push	r21
 68c:	6f 93       	push	r22
 68e:	7f 93       	push	r23
 690:	8f 93       	push	r24
 692:	9f 93       	push	r25
 694:	af 93       	push	r26
 696:	bf 93       	push	r27
 698:	ef 93       	push	r30
 69a:	ff 93       	push	r31
 69c:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
 6a0:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
 6a4:	e0 91 21 20 	lds	r30, 0x2021	; 0x802021 <adca_callback>
 6a8:	f0 91 22 20 	lds	r31, 0x2022	; 0x802022 <adca_callback+0x1>
 6ac:	62 e0       	ldi	r22, 0x02	; 2
 6ae:	80 e0       	ldi	r24, 0x00	; 0
 6b0:	92 e0       	ldi	r25, 0x02	; 2
 6b2:	19 95       	eicall
 6b4:	ff 91       	pop	r31
 6b6:	ef 91       	pop	r30
 6b8:	bf 91       	pop	r27
 6ba:	af 91       	pop	r26
 6bc:	9f 91       	pop	r25
 6be:	8f 91       	pop	r24
 6c0:	7f 91       	pop	r23
 6c2:	6f 91       	pop	r22
 6c4:	5f 91       	pop	r21
 6c6:	4f 91       	pop	r20
 6c8:	3f 91       	pop	r19
 6ca:	2f 91       	pop	r18
 6cc:	0f 90       	pop	r0
 6ce:	0b be       	out	0x3b, r0	; 59
 6d0:	0f 90       	pop	r0
 6d2:	0f be       	out	0x3f, r0	; 63
 6d4:	0f 90       	pop	r0
 6d6:	1f 90       	pop	r1
 6d8:	18 95       	reti

000006da <__vector_73>:
 6da:	1f 92       	push	r1
 6dc:	0f 92       	push	r0
 6de:	0f b6       	in	r0, 0x3f	; 63
 6e0:	0f 92       	push	r0
 6e2:	11 24       	eor	r1, r1
 6e4:	0b b6       	in	r0, 0x3b	; 59
 6e6:	0f 92       	push	r0
 6e8:	2f 93       	push	r18
 6ea:	3f 93       	push	r19
 6ec:	4f 93       	push	r20
 6ee:	5f 93       	push	r21
 6f0:	6f 93       	push	r22
 6f2:	7f 93       	push	r23
 6f4:	8f 93       	push	r24
 6f6:	9f 93       	push	r25
 6f8:	af 93       	push	r26
 6fa:	bf 93       	push	r27
 6fc:	ef 93       	push	r30
 6fe:	ff 93       	push	r31
 700:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
 704:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
 708:	e0 91 21 20 	lds	r30, 0x2021	; 0x802021 <adca_callback>
 70c:	f0 91 22 20 	lds	r31, 0x2022	; 0x802022 <adca_callback+0x1>
 710:	64 e0       	ldi	r22, 0x04	; 4
 712:	80 e0       	ldi	r24, 0x00	; 0
 714:	92 e0       	ldi	r25, 0x02	; 2
 716:	19 95       	eicall
 718:	ff 91       	pop	r31
 71a:	ef 91       	pop	r30
 71c:	bf 91       	pop	r27
 71e:	af 91       	pop	r26
 720:	9f 91       	pop	r25
 722:	8f 91       	pop	r24
 724:	7f 91       	pop	r23
 726:	6f 91       	pop	r22
 728:	5f 91       	pop	r21
 72a:	4f 91       	pop	r20
 72c:	3f 91       	pop	r19
 72e:	2f 91       	pop	r18
 730:	0f 90       	pop	r0
 732:	0b be       	out	0x3b, r0	; 59
 734:	0f 90       	pop	r0
 736:	0f be       	out	0x3f, r0	; 63
 738:	0f 90       	pop	r0
 73a:	1f 90       	pop	r1
 73c:	18 95       	reti

0000073e <__vector_74>:
 73e:	1f 92       	push	r1
 740:	0f 92       	push	r0
 742:	0f b6       	in	r0, 0x3f	; 63
 744:	0f 92       	push	r0
 746:	11 24       	eor	r1, r1
 748:	0b b6       	in	r0, 0x3b	; 59
 74a:	0f 92       	push	r0
 74c:	2f 93       	push	r18
 74e:	3f 93       	push	r19
 750:	4f 93       	push	r20
 752:	5f 93       	push	r21
 754:	6f 93       	push	r22
 756:	7f 93       	push	r23
 758:	8f 93       	push	r24
 75a:	9f 93       	push	r25
 75c:	af 93       	push	r26
 75e:	bf 93       	push	r27
 760:	ef 93       	push	r30
 762:	ff 93       	push	r31
 764:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
 768:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
 76c:	e0 91 21 20 	lds	r30, 0x2021	; 0x802021 <adca_callback>
 770:	f0 91 22 20 	lds	r31, 0x2022	; 0x802022 <adca_callback+0x1>
 774:	68 e0       	ldi	r22, 0x08	; 8
 776:	80 e0       	ldi	r24, 0x00	; 0
 778:	92 e0       	ldi	r25, 0x02	; 2
 77a:	19 95       	eicall
 77c:	ff 91       	pop	r31
 77e:	ef 91       	pop	r30
 780:	bf 91       	pop	r27
 782:	af 91       	pop	r26
 784:	9f 91       	pop	r25
 786:	8f 91       	pop	r24
 788:	7f 91       	pop	r23
 78a:	6f 91       	pop	r22
 78c:	5f 91       	pop	r21
 78e:	4f 91       	pop	r20
 790:	3f 91       	pop	r19
 792:	2f 91       	pop	r18
 794:	0f 90       	pop	r0
 796:	0b be       	out	0x3b, r0	; 59
 798:	0f 90       	pop	r0
 79a:	0f be       	out	0x3f, r0	; 63
 79c:	0f 90       	pop	r0
 79e:	1f 90       	pop	r1
 7a0:	18 95       	reti

000007a2 <__vector_39>:
 7a2:	1f 92       	push	r1
 7a4:	0f 92       	push	r0
 7a6:	0f b6       	in	r0, 0x3f	; 63
 7a8:	0f 92       	push	r0
 7aa:	11 24       	eor	r1, r1
 7ac:	0b b6       	in	r0, 0x3b	; 59
 7ae:	0f 92       	push	r0
 7b0:	2f 93       	push	r18
 7b2:	3f 93       	push	r19
 7b4:	4f 93       	push	r20
 7b6:	5f 93       	push	r21
 7b8:	6f 93       	push	r22
 7ba:	7f 93       	push	r23
 7bc:	8f 93       	push	r24
 7be:	9f 93       	push	r25
 7c0:	af 93       	push	r26
 7c2:	bf 93       	push	r27
 7c4:	ef 93       	push	r30
 7c6:	ff 93       	push	r31
 7c8:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
 7cc:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
 7d0:	e0 91 1f 20 	lds	r30, 0x201F	; 0x80201f <adcb_callback>
 7d4:	f0 91 20 20 	lds	r31, 0x2020	; 0x802020 <adcb_callback+0x1>
 7d8:	61 e0       	ldi	r22, 0x01	; 1
 7da:	80 e4       	ldi	r24, 0x40	; 64
 7dc:	92 e0       	ldi	r25, 0x02	; 2
 7de:	19 95       	eicall
 7e0:	ff 91       	pop	r31
 7e2:	ef 91       	pop	r30
 7e4:	bf 91       	pop	r27
 7e6:	af 91       	pop	r26
 7e8:	9f 91       	pop	r25
 7ea:	8f 91       	pop	r24
 7ec:	7f 91       	pop	r23
 7ee:	6f 91       	pop	r22
 7f0:	5f 91       	pop	r21
 7f2:	4f 91       	pop	r20
 7f4:	3f 91       	pop	r19
 7f6:	2f 91       	pop	r18
 7f8:	0f 90       	pop	r0
 7fa:	0b be       	out	0x3b, r0	; 59
 7fc:	0f 90       	pop	r0
 7fe:	0f be       	out	0x3f, r0	; 63
 800:	0f 90       	pop	r0
 802:	1f 90       	pop	r1
 804:	18 95       	reti

00000806 <__vector_40>:
 806:	1f 92       	push	r1
 808:	0f 92       	push	r0
 80a:	0f b6       	in	r0, 0x3f	; 63
 80c:	0f 92       	push	r0
 80e:	11 24       	eor	r1, r1
 810:	0b b6       	in	r0, 0x3b	; 59
 812:	0f 92       	push	r0
 814:	2f 93       	push	r18
 816:	3f 93       	push	r19
 818:	4f 93       	push	r20
 81a:	5f 93       	push	r21
 81c:	6f 93       	push	r22
 81e:	7f 93       	push	r23
 820:	8f 93       	push	r24
 822:	9f 93       	push	r25
 824:	af 93       	push	r26
 826:	bf 93       	push	r27
 828:	ef 93       	push	r30
 82a:	ff 93       	push	r31
 82c:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
 830:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
 834:	e0 91 1f 20 	lds	r30, 0x201F	; 0x80201f <adcb_callback>
 838:	f0 91 20 20 	lds	r31, 0x2020	; 0x802020 <adcb_callback+0x1>
 83c:	62 e0       	ldi	r22, 0x02	; 2
 83e:	80 e4       	ldi	r24, 0x40	; 64
 840:	92 e0       	ldi	r25, 0x02	; 2
 842:	19 95       	eicall
 844:	ff 91       	pop	r31
 846:	ef 91       	pop	r30
 848:	bf 91       	pop	r27
 84a:	af 91       	pop	r26
 84c:	9f 91       	pop	r25
 84e:	8f 91       	pop	r24
 850:	7f 91       	pop	r23
 852:	6f 91       	pop	r22
 854:	5f 91       	pop	r21
 856:	4f 91       	pop	r20
 858:	3f 91       	pop	r19
 85a:	2f 91       	pop	r18
 85c:	0f 90       	pop	r0
 85e:	0b be       	out	0x3b, r0	; 59
 860:	0f 90       	pop	r0
 862:	0f be       	out	0x3f, r0	; 63
 864:	0f 90       	pop	r0
 866:	1f 90       	pop	r1
 868:	18 95       	reti

0000086a <__vector_41>:
 86a:	1f 92       	push	r1
 86c:	0f 92       	push	r0
 86e:	0f b6       	in	r0, 0x3f	; 63
 870:	0f 92       	push	r0
 872:	11 24       	eor	r1, r1
 874:	0b b6       	in	r0, 0x3b	; 59
 876:	0f 92       	push	r0
 878:	2f 93       	push	r18
 87a:	3f 93       	push	r19
 87c:	4f 93       	push	r20
 87e:	5f 93       	push	r21
 880:	6f 93       	push	r22
 882:	7f 93       	push	r23
 884:	8f 93       	push	r24
 886:	9f 93       	push	r25
 888:	af 93       	push	r26
 88a:	bf 93       	push	r27
 88c:	ef 93       	push	r30
 88e:	ff 93       	push	r31
 890:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
 894:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
 898:	e0 91 1f 20 	lds	r30, 0x201F	; 0x80201f <adcb_callback>
 89c:	f0 91 20 20 	lds	r31, 0x2020	; 0x802020 <adcb_callback+0x1>
 8a0:	64 e0       	ldi	r22, 0x04	; 4
 8a2:	80 e4       	ldi	r24, 0x40	; 64
 8a4:	92 e0       	ldi	r25, 0x02	; 2
 8a6:	19 95       	eicall
 8a8:	ff 91       	pop	r31
 8aa:	ef 91       	pop	r30
 8ac:	bf 91       	pop	r27
 8ae:	af 91       	pop	r26
 8b0:	9f 91       	pop	r25
 8b2:	8f 91       	pop	r24
 8b4:	7f 91       	pop	r23
 8b6:	6f 91       	pop	r22
 8b8:	5f 91       	pop	r21
 8ba:	4f 91       	pop	r20
 8bc:	3f 91       	pop	r19
 8be:	2f 91       	pop	r18
 8c0:	0f 90       	pop	r0
 8c2:	0b be       	out	0x3b, r0	; 59
 8c4:	0f 90       	pop	r0
 8c6:	0f be       	out	0x3f, r0	; 63
 8c8:	0f 90       	pop	r0
 8ca:	1f 90       	pop	r1
 8cc:	18 95       	reti

000008ce <__vector_42>:
 8ce:	1f 92       	push	r1
 8d0:	0f 92       	push	r0
 8d2:	0f b6       	in	r0, 0x3f	; 63
 8d4:	0f 92       	push	r0
 8d6:	11 24       	eor	r1, r1
 8d8:	0b b6       	in	r0, 0x3b	; 59
 8da:	0f 92       	push	r0
 8dc:	2f 93       	push	r18
 8de:	3f 93       	push	r19
 8e0:	4f 93       	push	r20
 8e2:	5f 93       	push	r21
 8e4:	6f 93       	push	r22
 8e6:	7f 93       	push	r23
 8e8:	8f 93       	push	r24
 8ea:	9f 93       	push	r25
 8ec:	af 93       	push	r26
 8ee:	bf 93       	push	r27
 8f0:	ef 93       	push	r30
 8f2:	ff 93       	push	r31
 8f4:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
 8f8:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
 8fc:	e0 91 1f 20 	lds	r30, 0x201F	; 0x80201f <adcb_callback>
 900:	f0 91 20 20 	lds	r31, 0x2020	; 0x802020 <adcb_callback+0x1>
 904:	68 e0       	ldi	r22, 0x08	; 8
 906:	80 e4       	ldi	r24, 0x40	; 64
 908:	92 e0       	ldi	r25, 0x02	; 2
 90a:	19 95       	eicall
 90c:	ff 91       	pop	r31
 90e:	ef 91       	pop	r30
 910:	bf 91       	pop	r27
 912:	af 91       	pop	r26
 914:	9f 91       	pop	r25
 916:	8f 91       	pop	r24
 918:	7f 91       	pop	r23
 91a:	6f 91       	pop	r22
 91c:	5f 91       	pop	r21
 91e:	4f 91       	pop	r20
 920:	3f 91       	pop	r19
 922:	2f 91       	pop	r18
 924:	0f 90       	pop	r0
 926:	0b be       	out	0x3b, r0	; 59
 928:	0f 90       	pop	r0
 92a:	0f be       	out	0x3f, r0	; 63
 92c:	0f 90       	pop	r0
 92e:	1f 90       	pop	r1
 930:	18 95       	reti

00000932 <adc_write_configuration>:
 932:	bf 92       	push	r11
 934:	cf 92       	push	r12
 936:	df 92       	push	r13
 938:	ef 92       	push	r14
 93a:	ff 92       	push	r15
 93c:	0f 93       	push	r16
 93e:	1f 93       	push	r17
 940:	cf 93       	push	r28
 942:	df 93       	push	r29
 944:	1f 92       	push	r1
 946:	cd b7       	in	r28, 0x3d	; 61
 948:	de b7       	in	r29, 0x3e	; 62
 94a:	8c 01       	movw	r16, r24
 94c:	7b 01       	movw	r14, r22
 94e:	81 15       	cp	r24, r1
 950:	22 e0       	ldi	r18, 0x02	; 2
 952:	92 07       	cpc	r25, r18
 954:	71 f4       	brne	.+28     	; 0x972 <adc_write_configuration+0x40>
 956:	61 e2       	ldi	r22, 0x21	; 33
 958:	70 e0       	ldi	r23, 0x00	; 0
 95a:	82 e0       	ldi	r24, 0x02	; 2
 95c:	a1 d0       	rcall	.+322    	; 0xaa0 <nvm_read_byte>
 95e:	c8 2e       	mov	r12, r24
 960:	d1 2c       	mov	r13, r1
 962:	60 e2       	ldi	r22, 0x20	; 32
 964:	70 e0       	ldi	r23, 0x00	; 0
 966:	82 e0       	ldi	r24, 0x02	; 2
 968:	9b d0       	rcall	.+310    	; 0xaa0 <nvm_read_byte>
 96a:	dc 2c       	mov	r13, r12
 96c:	cc 24       	eor	r12, r12
 96e:	c8 2a       	or	r12, r24
 970:	10 c0       	rjmp	.+32     	; 0x992 <adc_write_configuration+0x60>
 972:	80 34       	cpi	r24, 0x40	; 64
 974:	92 40       	sbci	r25, 0x02	; 2
 976:	c1 f5       	brne	.+112    	; 0x9e8 <adc_write_configuration+0xb6>
 978:	65 e2       	ldi	r22, 0x25	; 37
 97a:	70 e0       	ldi	r23, 0x00	; 0
 97c:	82 e0       	ldi	r24, 0x02	; 2
 97e:	90 d0       	rcall	.+288    	; 0xaa0 <nvm_read_byte>
 980:	c8 2e       	mov	r12, r24
 982:	d1 2c       	mov	r13, r1
 984:	64 e2       	ldi	r22, 0x24	; 36
 986:	70 e0       	ldi	r23, 0x00	; 0
 988:	82 e0       	ldi	r24, 0x02	; 2
 98a:	8a d0       	rcall	.+276    	; 0xaa0 <nvm_read_byte>
 98c:	dc 2c       	mov	r13, r12
 98e:	cc 24       	eor	r12, r12
 990:	c8 2a       	or	r12, r24
 992:	8f b7       	in	r24, 0x3f	; 63
 994:	89 83       	std	Y+1, r24	; 0x01
 996:	f8 94       	cli
 998:	b9 80       	ldd	r11, Y+1	; 0x01
 99a:	c8 01       	movw	r24, r16
 99c:	d2 dd       	rcall	.-1116   	; 0x542 <adc_enable_clock>
 99e:	f8 01       	movw	r30, r16
 9a0:	80 81       	ld	r24, Z
 9a2:	92 e0       	ldi	r25, 0x02	; 2
 9a4:	90 83       	st	Z, r25
 9a6:	c4 86       	std	Z+12, r12	; 0x0c
 9a8:	d5 86       	std	Z+13, r13	; 0x0d
 9aa:	f7 01       	movw	r30, r14
 9ac:	25 81       	ldd	r18, Z+5	; 0x05
 9ae:	36 81       	ldd	r19, Z+6	; 0x06
 9b0:	f8 01       	movw	r30, r16
 9b2:	20 8f       	std	Z+24, r18	; 0x18
 9b4:	31 8f       	std	Z+25, r19	; 0x19
 9b6:	f7 01       	movw	r30, r14
 9b8:	92 81       	ldd	r25, Z+2	; 0x02
 9ba:	f8 01       	movw	r30, r16
 9bc:	92 83       	std	Z+2, r25	; 0x02
 9be:	f7 01       	movw	r30, r14
 9c0:	94 81       	ldd	r25, Z+4	; 0x04
 9c2:	f8 01       	movw	r30, r16
 9c4:	94 83       	std	Z+4, r25	; 0x04
 9c6:	f7 01       	movw	r30, r14
 9c8:	93 81       	ldd	r25, Z+3	; 0x03
 9ca:	f8 01       	movw	r30, r16
 9cc:	93 83       	std	Z+3, r25	; 0x03
 9ce:	f7 01       	movw	r30, r14
 9d0:	91 81       	ldd	r25, Z+1	; 0x01
 9d2:	f8 01       	movw	r30, r16
 9d4:	91 83       	std	Z+1, r25	; 0x01
 9d6:	81 70       	andi	r24, 0x01	; 1
 9d8:	f7 01       	movw	r30, r14
 9da:	90 81       	ld	r25, Z
 9dc:	89 2b       	or	r24, r25
 9de:	f8 01       	movw	r30, r16
 9e0:	80 83       	st	Z, r24
 9e2:	c8 01       	movw	r24, r16
 9e4:	cd dd       	rcall	.-1126   	; 0x580 <adc_disable_clock>
 9e6:	bf be       	out	0x3f, r11	; 63
 9e8:	0f 90       	pop	r0
 9ea:	df 91       	pop	r29
 9ec:	cf 91       	pop	r28
 9ee:	1f 91       	pop	r17
 9f0:	0f 91       	pop	r16
 9f2:	ff 90       	pop	r15
 9f4:	ef 90       	pop	r14
 9f6:	df 90       	pop	r13
 9f8:	cf 90       	pop	r12
 9fa:	bf 90       	pop	r11
 9fc:	08 95       	ret

000009fe <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
 9fe:	af 92       	push	r10
 a00:	bf 92       	push	r11
 a02:	cf 92       	push	r12
 a04:	df 92       	push	r13
 a06:	ef 92       	push	r14
 a08:	ff 92       	push	r15
 a0a:	0f 93       	push	r16
 a0c:	1f 93       	push	r17
 a0e:	cf 93       	push	r28
 a10:	df 93       	push	r29
 a12:	1f 92       	push	r1
 a14:	cd b7       	in	r28, 0x3d	; 61
 a16:	de b7       	in	r29, 0x3e	; 62
 a18:	6c 01       	movw	r12, r24
 a1a:	b6 2e       	mov	r11, r22
 a1c:	7a 01       	movw	r14, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
 a1e:	86 2f       	mov	r24, r22
 a20:	83 70       	andi	r24, 0x03	; 3
 a22:	29 f4       	brne	.+10     	; 0xa2e <adcch_write_configuration+0x30>
		index += 2;
		ch_mask >>= 2;
 a24:	96 2f       	mov	r25, r22
 a26:	96 95       	lsr	r25
 a28:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
 a2a:	82 e0       	ldi	r24, 0x02	; 2
 a2c:	02 c0       	rjmp	.+4      	; 0xa32 <adcch_write_configuration+0x34>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
 a2e:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
__always_inline static  ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
 a30:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
 a32:	90 ff       	sbrs	r25, 0
		index++;
 a34:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
 a36:	86 01       	movw	r16, r12
 a38:	00 5e       	subi	r16, 0xE0	; 224
 a3a:	1f 4f       	sbci	r17, 0xFF	; 255
 a3c:	98 e0       	ldi	r25, 0x08	; 8
 a3e:	89 9f       	mul	r24, r25
 a40:	00 0d       	add	r16, r0
 a42:	11 1d       	adc	r17, r1
 a44:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
 a46:	8f b7       	in	r24, 0x3f	; 63
 a48:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
 a4a:	f8 94       	cli
	return flags;
 a4c:	a9 80       	ldd	r10, Y+1	; 0x01
			return;
		}
	}
#endif

	adc_enable_clock(adc);
 a4e:	c6 01       	movw	r24, r12
 a50:	78 dd       	rcall	.-1296   	; 0x542 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
 a52:	f7 01       	movw	r30, r14
 a54:	80 81       	ld	r24, Z
 a56:	f8 01       	movw	r30, r16
 a58:	80 83       	st	Z, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
 a5a:	f7 01       	movw	r30, r14
 a5c:	82 81       	ldd	r24, Z+2	; 0x02
 a5e:	f8 01       	movw	r30, r16
 a60:	82 83       	std	Z+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
 a62:	f7 01       	movw	r30, r14
 a64:	81 81       	ldd	r24, Z+1	; 0x01
 a66:	f8 01       	movw	r30, r16
 a68:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
 a6a:	b0 fe       	sbrs	r11, 0
 a6c:	04 c0       	rjmp	.+8      	; 0xa76 <adcch_write_configuration+0x78>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
 a6e:	f7 01       	movw	r30, r14
 a70:	83 81       	ldd	r24, Z+3	; 0x03
 a72:	f8 01       	movw	r30, r16
	}
	adc_disable_clock(adc);
 a74:	86 83       	std	Z+6, r24	; 0x06
 a76:	c6 01       	movw	r24, r12
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 a78:	83 dd       	rcall	.-1274   	; 0x580 <adc_disable_clock>

	cpu_irq_restore(flags);
}
 a7a:	af be       	out	0x3f, r10	; 63
 a7c:	0f 90       	pop	r0
 a7e:	df 91       	pop	r29
 a80:	cf 91       	pop	r28
 a82:	1f 91       	pop	r17
 a84:	0f 91       	pop	r16
 a86:	ff 90       	pop	r15
 a88:	ef 90       	pop	r14
 a8a:	df 90       	pop	r13
 a8c:	cf 90       	pop	r12
 a8e:	bf 90       	pop	r11
 a90:	af 90       	pop	r10
 a92:	08 95       	ret

00000a94 <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
 a94:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
 a96:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
 a98:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
 a9a:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
 a9c:	60 83       	st	Z, r22
	ret                             // Return to caller
 a9e:	08 95       	ret

00000aa0 <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
 aa0:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
 aa4:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
 aa6:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
 aa8:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
 aac:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
 aae:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
 ab2:	08 95       	ret

00000ab4 <_exit>:
 ab4:	f8 94       	cli

00000ab6 <__stop_program>:
 ab6:	ff cf       	rjmp	.-2      	; 0xab6 <__stop_program>
